import {
    Cluster,
    ConfirmedSignatureInfo,
    Connection, PublicKey, SystemProgram,
} from '@solana/web3.js';
import { Poseidon } from '@elusiv/cryptojs';
import { bigIntToNumber, uint8ArrayToHex } from '@elusiv/serialization';
import { getMinimumBalanceForRentExemptAccount } from '@solana/spl-token';
import { CommitmentManager } from '../sdk/paramManagers/CommitmentManager.js';
import { FeeManager } from '../sdk/paramManagers/fee/FeeManager.js';
import { TransactionManager } from '../sdk/txManagers/TransactionManager.js';
import { TreeManager } from '../sdk/paramManagers/TreeManager.js';
import { TopupTxData } from './txData/TopupTxData.js';
import { TransactionSender } from '../sdk/txSending/TransactionSender.js';
import { SendTxData } from './txData/SendTxData.js';
import { MERGE_NEEDED, SEND_ARITY, VIEWING_KEY_VERSION } from '../constants.js';
import { ElusivTxData } from './txData/ElusivTxData.js';
import { PrivateTxWrapper } from './transactionWrappers/TxWrappers.js';
import { getAssociatedTokenAcc } from './tokenTypes/TokenTypeFuncs.js';
import { getDefaultWarden } from './WardenInfo.js';
import { RemoteParamFetching, topupRParamsToSendRParams } from '../sdk/transactions/txBuilding/RemoteParamFetching.js';
import { TransactionBuilding } from '../sdk/transactions/txBuilding/TransactionBuilding.js';
import { SeedWrapper } from '../sdk/clientCrypto/SeedWrapper.js';
import { tokenAccExists } from '../sdk/utils/pubKeyUtils.js';
import { generateViewingKey, ViewingKey } from '../compliance/ViewingKey.js';
import { addFees, getTotalFeeAmount } from './Fee.js';
import { FeeCalculator } from '../sdk/paramManagers/fee/FeeCalculator.js';
import { FeeUtils } from './FeeUtils.js';
import { ElusivViewer } from './elusivViewer.js';
import { isTypeError } from '../sdk/transactions/txBuilding/serializedTypes/typeGuards.js';
import { cleanUserInput, sleep } from '../sdk/utils/utils.js';
import { ElusivTransaction } from '../sdk/transactions/ElusivTransaction.js';
import {
    Fee, OptionalFee, PriceFetcher, SendFeeCalcInfo, TopupFeeCalcInfo,
} from './types.js';
import { TxTypes } from './TxTypes.js';
import { TokenType } from './tokenTypes/TokenType.js';
import { getPythPriceFetcher } from './pyth.js';
import { getWardenPubkey } from '../sdk/txSending/WardenCommunication.js';

export class Elusiv extends ElusivViewer {
    /**
     * Internal
     * Used for to speed up estimating getSendFeeEstimate and getSendFeeEstimate
     */
    private feeCalculatorCached?: FeeCalculator;

    /**
     * Internal
     * Used for to speed up estimating getSendFeeEstimate and getSendFeeEstimate
     */
    private tokenAccRentCached?: number;

    /**
     * Owner's public key
     */
    private ownerKey: PublicKey;

    /**
     * Warden pubkey
     */
    private wardenKey: PublicKey;

    /**
     * Warden URL
     */
    private wardenURL: string;

    /**
     * Internal
     */
    private feeManager: FeeManager;

    /**
     * Internal
     */
    private treeManager: TreeManager;

    /**
     * Internal
     */
    private txSender: TransactionSender;

    /**
     * Internal
    */
    private seedWrapper: SeedWrapper;

    /**
     * Internal
     */
    private priceFetcher: PriceFetcher;

    private constructor(
        cluster: Cluster,
        owner: PublicKey,
        wardenKey: PublicKey,
        wardenURL: string,
        connection: Connection,
        txManager: TransactionManager,
        feeManager: FeeManager,
        commManager: CommitmentManager,
        treeManager: TreeManager,
        seedWrapper: SeedWrapper,
        priceFetcher: PriceFetcher,
    ) {
        super(cluster, connection, txManager, commManager);
        this.ownerKey = owner;
        this.wardenKey = wardenKey;
        this.wardenURL = wardenURL;
        this.txSender = new TransactionSender();
        this.feeManager = feeManager;
        this.treeManager = treeManager;
        this.seedWrapper = seedWrapper;
        this.priceFetcher = priceFetcher;
    }

    /**
     * Instantiate the elusiv instance
     * @param seed Generated by signing the SEED_MESSAGE constant via edd25519. This seed allows anyone to decrypt and spend the user's private assets,
     * so handle this very carefully.
     * Should be treated like a password, no reason to show to user or even store in normal case.
     * @param owner Public key of user
     * @param connection Connection object to use to make calls to solana blockchain
     * @param cluster Cluster to operate on (e.g. 'devnet')
     * @param priceFetcher Optional external price fetcher to use. If not provided, the default pyth price fetcher will be used.
     */
    public static async getElusivInstance(
        seed: Uint8Array,
        owner: PublicKey,
        connection: Connection,
        cluster: Cluster,
        wardenURL = getDefaultWarden(cluster),
        priceFetcher: PriceFetcher = getPythPriceFetcher(connection, cluster),
    ): Promise<Elusiv> {
        // Intialize poseidon for cryptography
        const poseidonSetup = Poseidon.setupPoseidon();
        const seedWrapper = new SeedWrapper(seed);
        const feeManager = FeeManager.createFeeManager(connection, cluster);
        const txManager = TransactionManager.createTxManager(connection, cluster, seedWrapper.getRootViewingKeyWrapper());
        const treeManager = TreeManager.createTreeManager(connection, cluster);
        const commManager = CommitmentManager.createCommitmentManager(connection, cluster, treeManager, txManager);
        const wardenKey = await getWardenPubkey(wardenURL);
        const result = new Elusiv(cluster, owner, wardenKey, wardenURL, connection, txManager, feeManager, commManager, treeManager, seedWrapper, priceFetcher);
        // Finish initializing poseidon
        await poseidonSetup;
        return result;
    }

    /**
     * Build a tx to top up the private balance
     * @param amount Amount of the token to top up with
     * @param tokenType Type of token to topup with
     * @param manualMerge If too many topups (currently 4) are sent without a send inbetween (see docs on commitment management for more info), a merge is required.
     * If this boolean is set to false, this merge is done before building the topup if needed (i.e. the sdk user does not need to worry about this). Note: This means, a topup
     * might take longer to build at times as a merge needs to be built and confirmed prior.
     * If this boolean is set to true, this method will throw until a merge has been performed manually by the sdk user.
     * @param wardenURL Controls what warden is used. Filled in with default config.
     * @param sender Optional sender to use for the topup. Defaults to the owner of the elusiv instance.
     */
    public async buildTopUpTx(
        amount: number,
        tokenType: TokenType,
        manualMerge = false,
        sender = this.ownerKey,
        memo: string | undefined = undefined,
    ): Promise<TopupTxData> {
        const sanitizedAmount = cleanUserInput(amount);

        const remoteParams = await RemoteParamFetching.fetchTopupRemoteParams(
            this.connection,
            this.seedWrapper,
            this.commManager,
            this.txManager,
            this.feeManager,
            this.treeManager,
            tokenType,
            this.priceFetcher,
        );

        let mergeTxData: SendTxData | undefined;

        // If we have too many active commitments, we might need to merge before we can do our topup:
        if (CommitmentManager.needMerge(remoteParams.activeCommitments.toArray())) {
            if (manualMerge) throw new Error(MERGE_NEEDED);
            // Token send fee is 0, since we are merging which moves no money
            const asSendRParams = topupRParamsToSendRParams(remoteParams);
            mergeTxData = await TransactionBuilding.buildMergeTxData(
                tokenType,
                this.ownerKey,
                asSendRParams,
                { url: this.wardenURL, pubKey: this.wardenKey },
                this.seedWrapper,
            );

            await this.sendElusivTx(mergeTxData);

            // By now the recentblockhash & lastValidBlockheight are likely outdated, so overwrite them new
            remoteParams.chainState = await this.connection.getLatestBlockhash();
        }

        return TransactionBuilding.buildTopUpTxData(
            sanitizedAmount,
            tokenType,
            sender,
            false,
            remoteParams,
            { url: this.wardenURL, pubKey: this.wardenKey },
            this.seedWrapper,
            this.cluster,
            mergeTxData?.getTotalFeeAmount(),
            memo,
        );
    }

    /** Build a tx to withdraw all tokens of the specified token type from
     * the private balance to the public balance.
     *
     * @param tokenType Type of token to be withdrawn
     * @param allowOwnerOffCurve Controls wether we can send tokens to PDAs or other accounts whose public key does not lie on ed25519. Same idea as for
     * the getAssociatedTokenAddressSync function from the spl library.
     */
    public async buildWithdrawTx(
        tokenType: TokenType,
        extraFee: OptionalFee = { amount: BigInt(0), collector: SystemProgram.programId },
        allowOwnerOffCurve = false,
    ): Promise<SendTxData> {
        const tokenBalance = bigIntToNumber(await this.getLatestPrivateBalance(tokenType));
        // 5% buffer for price fluctuations while building, shouldn't be much since fees are < 1 ct
        const withdrawFee = getTotalFeeAmount(await this.estimateSendFee({ amount: tokenBalance, tokenType, recipient: this.ownerKey })) * 1.05;
        // < because obviously and = bc no point in withdrawing to only pay the fee and receive 0
        if (tokenBalance <= withdrawFee) throw new Error('Insufficient funds to pay for withdraw fee');
        // We add a small buffer to the fee for potential token price fluctuations
        const withdrawTx = await this.buildSendTx(tokenBalance - withdrawFee, this.ownerKey, tokenType, undefined, undefined, extraFee, false, allowOwnerOffCurve, undefined, undefined);
        if (withdrawTx.getTotalFeeAmount() > withdrawFee) throw new Error('Insufficient fee for withdraw tx, please try again.');
        return withdrawTx;
    }

    /** Build a tx to send tokens to a specified recipient using the private balance
     *
     * @param amount Amount of the token to be sent from the private balance. Must be at least the current price of rent for a token account.
     * @param recipient Recipient who should receive said amount of token. For the case of sending SPL-tokens, this is the recipient's owner account (i.e. the same one
     * you'd provide when sending SOL) *NOT* a token account. Be aware of this, to avoid your tokens being sent to the wrong account. Internally this is then mapped to
     * recipient's Associated Token Account.
     * @param tokenType Type of token to be sent
     * @param refKey Optional reference key to be included in final tx of the send, useful for e.g. Solana Pay
     * @param memo Optional memo to be included in final tx of the send, useful for e.g. Solana Pay. Maximum length 128 bytes in utf8.
     * @param extraFee Optional fee to be collected by a third party in the same TokenType as the send. If not provided, no fee will be collected. When specifying the collector here,
     * make sure its ATA already exists. If you wish to use a custom TA for the collector, use the customFeeCollectorTA parameter.
     * @param isSolanaPayTransfer Whether this is a transfer for Solana Pay. The main difference this makes is that the actual transfer of funds is done using a seperate
     * Transfer instruction, as required by the Solana Pay spec. If it is set to false, the transfer is done using a CPI. Defaults to false.
     * @param allowOwnerOffCurve Controls wether we can send tokens to PDAs or other accounts whose public key does not lie on ed25519. Same idea as for
     * the getAssociatedTokenAddressSync function from the spl library.
     * @param customRecipientTA For the case that you want to provide an override for a Token Account to send to that is not the recipient's ATA. Make sure this token account
     * is funded with rent, else this will fail.
     * @param customFeeCollectorTA For the case that you want to provide an override for a Token Account to collect the OptionalFee that is not the collector in
     * OptionalFee's ATA. Make sure this token account is funded with rent, else this will fail.
     * @param wardenURL Controls what warden is used. Filled in with default config.
     */
    public async buildSendTx(
        amount: number,
        recipient: PublicKey,
        tokenType: TokenType,
        refKey?: PublicKey,
        memo?: string,
        extraFee: OptionalFee = { amount: BigInt(0), collector: SystemProgram.programId },
        isSolanaPayTransfer = false,
        allowOwnerOffCurve = false,
        customRecipientTA: PublicKey | undefined = undefined,
        customFeeCollectorTA: PublicKey | undefined = undefined,
    ): Promise<SendTxData> {
        const sanitizedAmount = cleanUserInput(amount);

        const recipientTA = customRecipientTA === undefined ? getAssociatedTokenAcc(recipient, tokenType, this.cluster, allowOwnerOffCurve) : customRecipientTA;
        let extraFeeCollectorTA: PublicKey | undefined;
        if (extraFee) extraFeeCollectorTA = customFeeCollectorTA || getAssociatedTokenAcc(extraFee.collector, tokenType, this.cluster, true);

        // There is no such thing as a TA for Lamports, so always falses in that case
        const existsRecipientTA = (tokenType !== 'LAMPORTS') && tokenAccExists(this.connection, recipientTA);
        const existsExtraFeeTA = extraFeeCollectorTA === undefined
            || (tokenType !== 'LAMPORTS'
                && tokenAccExists(this.connection, extraFeeCollectorTA));

        // No need to initialize collector account for TA
        if (tokenType !== 'LAMPORTS' && !existsExtraFeeTA) throw new Error('Fee collector token account must exist prior to sending');
        if (!existsRecipientTA && customRecipientTA !== undefined) throw new Error('Custom recipient TA must exist prior to sending');

        return RemoteParamFetching.fetchSendRemoteParams(
            this.connection,
            this.seedWrapper,
            this.commManager,
            this.txManager,
            this.feeManager,
            this.treeManager,
            tokenType,
            this.priceFetcher,
        ).then(async (res) => TransactionBuilding.buildSendTxData(
            sanitizedAmount,
            tokenType,
            { TA: recipientTA, owner: recipient, exists: await existsRecipientTA },
            this.ownerKey,
            res,
            { url: this.wardenURL, pubKey: this.wardenKey },
            this.seedWrapper,
            refKey,
            memo,
            // Can turn off warnings here because we know extraFeeCollectorTA gets created if extraFee exists
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            extraFee ? { amount: extraFee.amount, collector: extraFeeCollectorTA! } : extraFee,
            isSolanaPayTransfer,
        ));
    }

    /**
     * Send off a tx built with one of the elusiv tx building methods. IMPORTANT: An Elusiv transaction is NOT
     * the same as a regular solana transaction, it usually consists of more than one Solana transaction under the hood.
     * (This method is equivalent to calling sendElusivTxWithTracking and then waiting for the commitmentInsertionPromise
     * to resolve before returning)
     * @param txData The built Elusiv tx
     * @returns A sig of the completed Elusiv transaction indicating your transaction was successful and that you can send
     * the next elusiv transaction right away.
     */
    public async sendElusivTx(txData: ElusivTxData): Promise<ConfirmedSignatureInfo> {
        const res = await this.sendElusivTxWithTracking(txData);
        await res.commitmentInsertionPromise;
        return res.elusivTxSig;
    }

    /**
     * Send off a tx built with one of the elusiv tx building methods and returns better tracking information about
     * the progress of the transaction under the hood for nicer display to the user.
     * IMPORTANT: An Elusiv transaction is NOT the same as a regular solana transaction, it usually consists of
     * more than one Solana transaction under the hood.
     * @param txData The built Elusiv tx
     * @returns A sig of the completed elusiv transaction indicating your transaction was successful and a promise that resolves once the next commitment
     * has been inserted i.e. once you can send the next elusiv transaction.
     */
    public async sendElusivTxWithTracking(txData: ElusivTxData): Promise<{ elusivTxSig: ConfirmedSignatureInfo, commitmentInsertionPromise: Promise<boolean> }> {
        // Sig for the of a confirmed elusiv transaction
        let elusivTxSig: ConfirmedSignatureInfo;
        try {
            elusivTxSig = await this.txSender.sendElusivTx(txData);
        }
        catch (err: unknown) {
            // Sometimes the warden will return 'fetch failed' even though everything went well because
            // of its websockets closing the connection due to timeout. Until this is fixed, catch and double check this case.
            if (isTypeError(err) && err.message === 'fetch failed') {
                const mostRecent = (await this.txManager.fetchTxs(1))[0];
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                if (mostRecent !== undefined && mostRecent.nonce === txData.lastNonce + 1) elusivTxSig = mostRecent.signature!;
                else throw err;
            }
            else throw err;
        }

        const commitmentInsertionPromise = this.commManager.awaitCommitmentInsertion(txData.commitmentHash, txData.merkleStartIndex, undefined, 10 * 60 * 1000).then(async (foundComm) => {
            let foundSig = false;
            if (foundComm) {
                const isMerge = txData.txType === 'TOPUP' && (txData as TopupTxData).merge;
                foundSig = await this.findSig(txData.lastNonce, txData.txType, isMerge, 500, 120);
            }
            if (!foundSig || !foundComm) {
                const idKey = this.seedWrapper.getRootViewingKeyWrapper().getIdentifierKey(txData.lastNonce + 1);
                throw new Error(`Could not find sig ${elusivTxSig} for key ${idKey.toBase58()} after sending`);
            }

            return foundSig && foundComm;
        });

        return { elusivTxSig, commitmentInsertionPromise };
    }

    /**
     * Generates a viewing key for a send transaction. With this viewing key a third party
     * can verify who the original sender of your private transaction was.
     * @param sendTx The send transaction for which to generate the viewing key.
     * @returns The viewing key and the signature of the send transaction it can decrypt as an object.
     */
    // eslint-disable-next-line class-methods-use-this
    public getViewingKey(sendTx: PrivateTxWrapper): ViewingKey {
        if (sendTx.txType !== 'SEND') throw new Error('Cannot generate viewing key for non-send tx');
        const rvk = this.seedWrapper.getRootViewingKeyWrapper();
        const viewingKey = uint8ArrayToHex(generateViewingKey(rvk, sendTx.nonce));
        const idKey = uint8ArrayToHex(rvk.getIdentifierKey(sendTx.nonce).toBytes());
        return { version: uint8ArrayToHex(new Uint8Array(VIEWING_KEY_VERSION)), decryptionKey: viewingKey, idKey };
    }

    /**
     * Generates the root viewing key (rvk). With the rvk a third party
     * can decrypt/view ALL private assets and transactions (but not spend).
     * @returns The root viewing key for this private account in hex with leading 0x.
     */
    // eslint-disable-next-line class-methods-use-this
    public getRootViewingKey(): string {
        return uint8ArrayToHex(this.seedWrapper.getRootViewingKeyWrapper().getRootViewingKey());
    }

    /**
     * Estimate how much a topup will cost based on current price data. This is not 100% accurate, as
     * fee data can fluctuate.
     * @param feeCalcInfo Information needed to calculate the fee for a topup transaction
     * @returns An estimate for how much the topup will cost
     */
    public async estimateTopupFee(feeCalcInfo: TopupFeeCalcInfo): Promise<Fee> {
        return this.estimateTopupFeesBatch([feeCalcInfo]).then((res) => res[0]);
    }

    /**
     * Estimate how much CONSECUTIVE topups will cost based on current price data. This is not 100% accurate, as
     * fee data can fluctuate due to token prices changing. The reason the CONSECUTIVE part is relevant is because
     * if you send too many topups without a send inbetween, a merge is required, which costs more than a topup, which this
     * method takes into account.
     * @param feeCalcInfos Information needed to calculate the fee for the topup transactions
     * @returns An array of estimates for how much the topups will cost in the same order as the provided feeCalcInfos
     */
    public async estimateTopupFeesBatch(feeCalcInfos: TopupFeeCalcInfo[]): Promise<Fee[]> {
        const feeCalculatorPromise = this.feeCalculatorCached
            ? Promise.resolve(this.feeCalculatorCached)
            : this.feeManager.getFeeCalculator().then((f) => f.calculator);
        const tokenAccRentPromise = this.tokenAccRentCached
            ? Promise.resolve(this.tokenAccRentCached)
            : getMinimumBalanceForRentExemptAccount(this.connection);
        // Every SEND_ARITY topups, we need to merge
        const tokenPriceMap = await this.getTokenPriceMap(feeCalcInfos.map((feeCalcInfo) => feeCalcInfo.tokenType));
        // Count how many of which token types topups we have
        const tokenTxCountMap = new Map<TokenType, number>();
        const res: Promise<Fee>[] = [];
        for (const feeCalcInfo of feeCalcInfos) {
            const seenCount = tokenTxCountMap.get(feeCalcInfo.tokenType) ?? 0;
            const tokenPrice = tokenPriceMap.get(feeCalcInfo.tokenType) ?? -1;

            if (seenCount === SEND_ARITY) {
                // If we have seen SEND_ARITY topups, we need to merge, so add the cost of one merge tx
                res.push(
                    this.estimateSendFeeInternal({ ...feeCalcInfo, recipient: SystemProgram.programId }, false, tokenPrice, tokenAccRentPromise, feeCalculatorPromise)
                        .then(async (sendFee) => addFees(sendFee, await this.estimateTopupFeeInternal(feeCalcInfo, tokenPrice, feeCalculatorPromise))),
                );
                // We're back to 2 commitments available for this token type (the merge result and the one we just created)
                tokenTxCountMap.set(feeCalcInfo.tokenType, 2);
            }
            else {
                res.push(Promise.resolve(this.estimateTopupFeeInternal(feeCalcInfo, tokenPrice, feeCalculatorPromise)));
                tokenTxCountMap.set(feeCalcInfo.tokenType, seenCount + 1);
            }
        }
        return Promise.all(res);
    }

    /**
     * Estimate how much a send will cost based on current price data. This is not 100% accurate, as
     * fee data can fluctuate due to token prices changing.
     * @param feeCalcInfo Information needed to calculate the fee for a send transaction
     * @param allowOwnerOffCurve Controls wether we can send tokens to PDAs or other accounts whose public key does not lie on ed25519. Same idea as for
     * the getAssociatedTokenAddressSync function from the spl library.
     * @returns An estimate for how much the send will cost
     */
    public async estimateSendFee(feeCalcInfo: SendFeeCalcInfo, allowOwnerOffCurve = false): Promise<Fee> {
        return this.estimateSendFeesBatch([feeCalcInfo], allowOwnerOffCurve).then((res) => res[0]);
    }

    /**
     * Estimate how much a send will cost based on current price data for a batch of potential sends. This is not 100% accurate, as
     * fee data can fluctuate due to token prices changing.
     * @param feeCalcInfos Information needed to calculate the fee for the send transactions
     * @param allowOwnerOffCurve Controls wether we can send tokens to PDAs or other accounts whose public key does not lie on ed25519. Same idea as for
     * the getAssociatedTokenAddressSync function from the spl library.
     * @returns An array of estimates for how much the sends will cost in the same order as the provided feeCalcInfos
     */
    public async estimateSendFeesBatch(feeCalcInfos: SendFeeCalcInfo[], allowOwnerOffCurve = false): Promise<Fee[]> {
        const feeCalculatorPromise = this.feeCalculatorCached
            ? Promise.resolve(this.feeCalculatorCached)
            : this.feeManager.getFeeCalculator().then((f) => f.calculator);
        const tokenAccRentPromise = this.tokenAccRentCached
            ? Promise.resolve(this.tokenAccRentCached)
            : getMinimumBalanceForRentExemptAccount(this.connection);
        const tokenPriceMap = await this.getTokenPriceMap(feeCalcInfos.map((feeCalcInfo) => feeCalcInfo.tokenType));

        const res: Promise<Fee>[] = [];
        for (const feeCalcInfo of feeCalcInfos) {
            res.push(this.estimateSendFeeInternal(feeCalcInfo, allowOwnerOffCurve, tokenPriceMap.get(feeCalcInfo.tokenType) ?? -1, tokenAccRentPromise, feeCalculatorPromise));
        }
        return Promise.all(res);
    }

    /**
     * Derive a key from the seed using hkdf. The ikm is the provided seed.
     * @param info Must be a string with length greater than 0. Cannot start with "elusiv".
     * @param salt Salt to be used.
     * @param length Length of the expected output key in bytes.
     * @returns The derived key.
     */
    public deriveKeyExternal(info: string, salt: number, length: number): Uint8Array {
        return this.seedWrapper.deriveKeyExternal(info, salt, length);
    }

    public setPriceFetcher(priceFetcher: PriceFetcher): void {
        this.priceFetcher = priceFetcher;
    }

    private async estimateSendFeeInternal(
        feeCalcInfo: SendFeeCalcInfo,
        allowOwnerOffCurve: boolean,
        lamportsPerToken: number,
        tokenAccRentPromise: Promise<number>,
        feeCalculatorPromise: Promise<FeeCalculator>,
    ): Promise<Fee> {
        if (lamportsPerToken === -1) throw new Error(`Invalid Token price for token ${feeCalcInfo.tokenType}`);
        const recipientTA = await (feeCalcInfo.customRecipientTA === undefined ? getAssociatedTokenAcc(feeCalcInfo.recipient, feeCalcInfo.tokenType, this.cluster, allowOwnerOffCurve) : feeCalcInfo.customRecipientTA);
        // There is no such thing as a TA for Lamports, so always already exists in that case
        const existsTAPromise = (feeCalcInfo.tokenType === 'LAMPORTS') || tokenAccExists(this.connection, recipientTA);
        const [existsTA, tokenAccRent, feeCalculator] = await Promise.all([existsTAPromise, tokenAccRentPromise, feeCalculatorPromise]);
        this.tokenAccRentCached = tokenAccRent;
        this.feeCalculatorCached = feeCalculator;
        const lamportFee = this.feeCalculatorCached.estimateSendFee(cleanUserInput(feeCalcInfo.amount), existsTA, this.tokenAccRentCached);
        return FeeUtils.lamportFeeToTokenFee(lamportFee, feeCalcInfo.tokenType, await lamportsPerToken, feeCalcInfo.extraFee ? bigIntToNumber(feeCalcInfo.extraFee.amount) : 0);
    }

    private async estimateTopupFeeInternal(
        feeCalcInfo: TopupFeeCalcInfo,
        lamportsPerToken: number,
        feeCalculatorPromise: Promise<FeeCalculator>,
    ): Promise<Fee> {
        this.feeCalculatorCached = await feeCalculatorPromise;
        const lamportFee = this.feeCalculatorCached.estimateStoreFee(cleanUserInput(feeCalcInfo.amount));
        return FeeUtils.lamportFeeToTokenFee(lamportFee, feeCalcInfo.tokenType, lamportsPerToken, 0);
    }

    /**
     * Get the token prices for each provided unique token
     * @param tokenTypes The token types for which to get the prices (May contain duplicated)
     * @returns A map from token type to price in Lamports
     */
    private async getTokenPriceMap(tokenTypes: TokenType[]): Promise<Map<TokenType, number>> {
        const uniqueTokens = [...new Set(tokenTypes)];
        const tokenPriceMap = new Map<TokenType, number>();
        await Promise.all([...uniqueTokens].map(async (tokenType) => {
            const price = await FeeUtils.getLamportsPerToken(this.priceFetcher, tokenType);
            tokenPriceMap.set(tokenType, price);
        }));
        return tokenPriceMap;
    }

    /**
     * Try finding a the sigs for an id key on-chain to ensure a tx was successfull.
     * @param sig The signature to find
     */
    private async findSig(lastNonce: number, txType: TxTypes, isMerge: boolean, msBetweenFetches = 500, maxCalls = 10): Promise<boolean> {
        const currNonce = isMerge ? lastNonce + 2 : lastNonce + 1;
        for (let i = 0; i < maxCalls; i++) {
            // eslint-disable-next-line no-await-in-loop
            const privTxs = await this.txManager.fetchTxs(5);
            const matchingSig = privTxs.find((tx) => tx.nonce === currNonce && tx.txType === txType);
            let mergeTx: ElusivTransaction | undefined;
            if (isMerge) {
                mergeTx = privTxs.find((tx) => tx.nonce === lastNonce + 1 && tx.txType === 'SEND');
            }
            if (matchingSig !== undefined && (!isMerge || mergeTx !== undefined)) return true;
            // eslint-disable-next-line no-await-in-loop
            await sleep(msBetweenFetches);
        }
        return false;
    }
}
